import java.nio.file.StandardCopyOption
import java.nio.file.Files
import java.text.SimpleDateFormat
import java.util.Date

// https://docs.gradle.org/current/userguide/building_java_projects.html#sec:java_packaging
plugins {
    id 'java'
    // For source code formatting
    id "com.diffplug.spotless" version "6.25.0"
	// https://github.com/harbby/gradle-serviceloader
    id "com.github.harbby.gradle.serviceloader" version "1.1.8"
	// For building shadow jars with jdk 17 ONLY
    //id 'com.github.johnrengelman.shadow' version '8.1.1'
    // For building shadow jars using JDK 21 +, they had to fork
    id "io.github.goooler.shadow" version "8.1.7"
    // Download task
    id "de.undercouch.download" version "5.6.0"
	// Task visualizer
	id "com.dorongold.task-tree" version "4.0.0"
}

/**
 * Project Properties
 */
sourceCompatibility = jdkVersion
targetCompatibility = jdkVersion
ext {
	buildID = System.getenv( 'BUILD_ID' ) ?: '0'
	branch = System.getenv( 'BRANCH' ) ?: 'development'
}

repositories {
    mavenLocal()
    mavenCentral()
}

dependencies {
	// LOCAL DEVELOPMENT ONLY
	// CHOOSE THE RIGHT LOCATION FOR YOUR LOCAL DEPENDENCIES
    implementation files( '../boxlang/build/distributions/boxlang-' + boxlangVersion + '-all.jar' )
	implementation files( '../boxlang-web-support/build/distributions/boxlang-web-support-' + boxlangVersion + '.jar' )

	// Downloaded Dependencies
	implementation files( 'src/test/resources/libs/boxlang-web-support-' + boxlangVersion + '.jar' )
	implementation files( 'src/test/resources/libs/boxlang-' + boxlangVersion + '-all.jar' )

	// Servlet API
	implementation 'javax.servlet:javax.servlet-api:4.0.1'

 	implementation 'commons-fileupload:commons-fileupload:1.4'

    // Testing Dependencies
    testImplementation "org.junit.jupiter:junit-jupiter:5.+"
	testImplementation "org.mockito:mockito-core:5.+"
	testImplementation "com.google.truth:truth:1.+"
}

java {
	withJavadocJar()
}

compileJava {
	// Compiler Options
	options.incremental = true
	options.encoding = 'UTF-8'
	options.debug()
}

compileTestJava {
	source sourceSets.test.java
	dependsOn compileJava, serviceLoaderBuild
	options.encoding = 'UTF-8'
}

jar {
    archiveVersion =  "${version}"
 	manifest {
	   	attributes 'Description': 'The BoxLang Servlet Runtime'
		 if( branch == 'development' ){
		   attributes 'Implementation-Version': "${version}-SNAPSHOT"
	   } else {
		   attributes 'Implementation-Version': "${version}+${buildID}"
	   }
	   attributes 'Created-On': new SimpleDateFormat( "yyyy-MM-dd HH:mm:ss" ).format( new Date() )
	   attributes 'Created-By': "Ortus Solutions, Corp"
    }
}

shadowJar {
    destinationDirectory = file( "build/distributions" )
	mergeServiceFiles()
	exclude "schema/**"
	exclude "org/antlr/v4/gui/**"
	exclude "org/antlr/v4/gui/**"
	exclude "com/ibm/icu/**"
}
build.dependsOn( shadowJar );

/**
 * Docs are here:
 * - https://github.com/harbby/gradle-serviceloader,
 * - https://plugins.gradle.org/plugin/com.github.harbby.gradle.serviceloader
 * This generates the META-INF/services files for the ServiceLoader as part of the `build` task
 */
serviceLoader {
    serviceInterface 'ortus.boxlang.runtime.bifs.BIF'
    serviceInterface 'ortus.boxlang.runtime.components.Component'
    serviceInterface 'ortus.boxlang.runtime.async.tasks.IScheduler'
    serviceInterface 'ortus.boxlang.runtime.cache.providers.ICacheProvider'
	serviceInterface 'ortus.boxlang.runtime.events.IInterceptor'
}

/**
 * Token Replacements for files
 */
import org.apache.tools.ant.filters.ReplaceTokens
processResources {
	// Replace @build.date@ with the current date in META-INF/version.properties file
	filter( ReplaceTokens, tokens: [ 'build.date': new SimpleDateFormat( "yyyy-MM-dd HH:mm:ss" ).format( new Date() ) ] )
	// Replace @build.version@ with the current version in META-INF/version.properties file
	filter( ReplaceTokens, tokens: [ 'build.version': version ] )
	// If we are in branch == development then update +build.number to -SNAPSHOT
	if( branch == 'development' ){
		filter( ReplaceTokens, tokens: [ 'build.number': "-SNAPSHOT" ] )
	} else {
		filter( ReplaceTokens, tokens: [ 'build.number': "+" + buildID ] )
	}
}

javadoc {
    // To avoid our own doclet issues
	options.addBooleanOption( "Xdoclint:none", true )
	options.addBooleanOption( 'html5', true )
}
task zipJavadocs( type: Zip ) {
	dependsOn javadoc
	group "documentation"
	from javadoc.destinationDir
	archiveFileName = "${project.name}-javadocs-${version}.zip"
	destinationDirectory = file( "$buildDir/distributions" )
	// Output that the docs have been zippped
	doLast {
		println "+ Javadocs have been zipped to the distribution folder"
	}
}
javadoc.finalizedBy( zipJavadocs )

/**
 * Source Code Formatting
 */
spotless {
    java {
		target fileTree( "." ) {
            include "**/*.java"
            exclude "**/build/**", "bin/**", "examples/**"
        }
        eclipse().configFile( "./.ortus-java-style.xml" )
		toggleOffOn()
    }
}

test {
    useJUnitPlatform()
    testLogging {
		showStandardStreams = true
	}
}

/**
 * Create the engine distribution
 */
task createWar( type: Copy ){
	dependsOn( shadowJar )
	// Move the runtime
	from( "build/distributions" ) {
		include "${project.name}-${version}-all.jar"
        into "engine/WEB-INF/lib"
    }
	// License it up
	from( "src/main/resources/META-INF/boxlang-servelet/license.txt" ) {
		include "license.txt"
	}
	// Resources
	from( "src/main/resources/boxlang-servlet" ) {
		include "web.xml"
		include "box.json"
		// Token Replacements Go Here
		filter{ line -> line.replaceAll( '@build.version@', project.version ) }
		if( project.branch == "development" ){
			filter{ line -> line.replaceAll( '\\+@build.number@', '-SNAPSHOT' ) }
		} else {
			filter{ line -> line.replaceAll( '@build.number@', project.buildID ) }
		}
		into "engine/WEB-INF"
	}
	// Move to distro for packaging
	from( "build/engine/WEB-INF" ){
		include "box.json"
		into "distributions"
	}
	destinationDir = file( "build" )
	doLast {
		println "+ Engine has been created in the build/engine folder"
	}
}
task packageWar( type: War ){
	dependsOn( createWar )
	archiveFileName = "${project.name}-${version}.war"
	destinationDirectory = file( 'build/distributions' )
	from( 'build/engine' )
	doLast {
		println "+ War created in the distributions folder"
	}
}
task buildRuntime( type: Copy ){
	dependsOn( packageWar )
	from( 'build/distributions' ) {
		include "${project.name}-${version}.war"
		include "box.json"
	}
	destinationDir = file( 'build/forgebox' )

	doLast {
		file( "build/evergreen" ).mkdirs()
		if( branch == 'development' ){
			Files.copy( file( "build/distributions/boxlang-servlet-${version}.war" ).toPath(), file( "build/evergreen/boxlang-servlet-snapshot.war" ).toPath(), StandardCopyOption.REPLACE_EXISTING )
			Files.copy( file( "build/distributions/boxlang-servlet-${version}-all.jar" ).toPath(), file( "build/evergreen/boxlang-servlet-snapshot-all.jar" ).toPath(), StandardCopyOption.REPLACE_EXISTING )
		} else {
			Files.copy( file( "build/distributions/boxlang-servlet-${version}.zip" ).toPath(), file( "build/evergreen/boxlang-servlet-latest.zip" ).toPath(), StandardCopyOption.REPLACE_EXISTING )
		}

		println "+ CommandBox Engine created in the build/forgebox folder, ready for publishing"
	}
}

/**
 * TEMPORARY until we publish to maven
 * Task to download the latest jar from https://ortus-temp.s3.amazonaws.com/jericho/libs/boxlang-1.0.0-all.jar
 */
task downloadBoxLang( type: Download ) {
	// Create the destination directory
	doFirst {
		file( "src/test/resources/libs" ).mkdirs()
	}
	// Configure the URLs of the files to download
	src([
		"https://downloads.ortussolutions.com/ortussolutions/boxlang/${boxlangVersion}/boxlang-${boxlangVersion}-all.jar",
		"https://downloads.ortussolutions.com/ortussolutions/boxlang-runtimes/boxlang-web-support/${boxlangVersion}/boxlang-web-support-${boxlangVersion}.jar"
	])
	// Specify the destination directories for the downloaded files
	dest "src/test/resources/libs/"
    overwrite true
    onlyIfModified false
}

/**
 * Project Wide Helper function
 * This is not a task, but a reusable UDF
 */
project.ext.bumpVersion = {
	boolean major = false,
	boolean minor = false,
	boolean patch = false,
	boolean beta = false,
	property = "version" ->

	def propertiesFile = file( './gradle.properties' );
	def properties = new Properties();

	properties.load( propertiesFile.newDataInputStream() )
	def versionTarget = major ? 0 : minor ? 1 : 2

	def currentVersion = properties.getProperty( property )
	def versionParts = currentVersion.split( '\\.' )
	if( !beta ){
		def newPathVersion = versionParts[ versionTarget ].toInteger() + 1
	}
	def newVersion = '';

	if( patch ){
		newVersion = "${versionParts[ 0 ]}.${versionParts[ 1 ]}.${newPathVersion}"
	} else if( minor ){
		newVersion = "${versionParts[ 0 ]}.${newPathVersion}.${versionParts[ 2 ]}"
	} else if( major ){
		newVersion = "${newPathVersion}.${versionParts[ 1 ]}.${versionParts[ 2 ]}"
	} else if( beta ){
		// Get's the -betaX version.
		def betaString = currentVersion.split( '-' )[ 1 ]
		// Now we get the beta number
		def betaNumber = betaString.split( 'beta' )[ 1 ].toInteger() + 1
		newVersion = currentVersion.split( '-' )[ 0 ] + "-beta${betaNumber}"
	}

	properties.setProperty( property, newVersion )
	properties.store( propertiesFile.newWriter(), null )

	println "Bumped version from ${currentVersion} to ${newVersion}"
}

/**
 * Bump the major version number
 */
task bumpMajorVersion {
	doLast{
		bumpVersion( true, false, false, false, "version" )
		bumpVersion( true, false, false, false, "boxlangVersion" )
	}
}

/**
 * Bump the minor version number
 */
task bumpMinorVersion {
	doLast{
		bumpVersion( false, true, false, false, "version" )
		bumpVersion( false, true, false, false, "boxlangVersion" )
	}
}

/**
 * Bump the patch version number
 */
task bumpPatchVersion {
	doLast{
		bumpVersion( false, false, true, false, "version" )
		bumpVersion( false, false, true, false, "boxlangVersion" )
	}
}

/**
 * Bump the beta version number
 */
task bumpBetaVersion {
	doLast{
		bumpVersion( false, false, false, true, "version" )
		bumpVersion( false, false, false, true, "boxlangVersion" )
	}
}
